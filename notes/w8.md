# **[CS 2110] - Week 8: Recursion & Input/Output (I/O)**
## Recursion
- using a stack gives us recursion for free
- the following sections of code for subroutines stay the same for recursion:
	- initial code (push arguments and JSR, make room for local variables, save registers)
	- ending code (prepare return value, restore registers, clean up stack, RET)
- the body code just contains a recursive call to the subroutine
- if you use a well-designed calling sequence, a recursive function call looks just like any other function call; a recursive function looks just like any other function

---
## Input/Output (I/O)
### Synchronicity
- asynchronous
	- electronic, mechanical, and human speed
	- speed mismatch
- synchronous
	- processor operation
	- certain kinds of high speed I/O

### Transfer Timing
- I/O events generally happen much more slowly than CPU cycles
- synchronous
	- data supplied at a fixed, predictable rate
	- CPU reads/writes every X cycles
- asynchronous
	- data rate less predictable
	- CPU must synchronize with device, so that it doesn't miss data or write too quickly

### Two Methods Of Doing I/O
- special I/O instructions
	- need an opcode
	- need to be general enough to work with devices that haven't been invented yet
- memory-mapped I/O
	- steal part of the address space for device registers
	- operations done by reading/writing bits in the device registers

### Device Registers
- **data register**: used for the actual transfer of data (ex. character code)
	- device registers are often part of the I/O device itself
- **status register**: information the device is telling us
- **control register**: allows us to set changeable device characteristics
- options
	- may be memory mapped (aka has a memory address)
	- may have special I/O instructions

### Memory Mapped vs. Special I/O Instructions
- if device registers are located at valid memory addresses, how can we access them?
	- interrupt-driven
	- polling

### Interrupt-Driven vs. Polling
- the two ways to handle I/O completion
- interrupt-driven
	- "excuse me, I have just given you a character"
- polling
	- "has a character been typed?"
	- "has a character been typed?"
	- "has a character been typed?"
	- "has a character been typed?"
	- "has a character been typed?"
	- "has a character been typed?"
	- ...

### LC-3 Address Space
![[../img/w8-ss1-lc-3-address-space.png|500]]
- 512 device registers ($2^9$, because 9 bits can be set)

### Keyboard Input
![[../img/w8-ss2-kbsr.png|300]]
- KBSR (xFE00)
	- keyboard status register
	- only uses 1 bit (uses bit 15)
	- bit 15 is set when the character is available

![[../img/w8-ss3-kbdr.png|300]]
- KBDR (xFE02)
	- keyboard data register
	- really only need 8 bits but 16 bit is easier
	- this location is read-only
	- reading clears KBSR
- there is also an interrupt enable bit not shown in KBSR to indicate we want to be interrupted when KBSR\[15\] is set to 1

### Memory Mapped Input
![[../img/w8-ss4-memory-mapped-input.png]]

### Example Code: Reading From The Keyboard
```
; Read characters from the keyboard until CTRL/Z
		.orig x3000
		LD	R4, TERM
		LEA	R2, BUFFER	;initialize buffer pointer
START	LDI	R1, KBSRA	;see if a char is there
		BRzp	START
		LDI	R0, KBDRA	;get the character
		STR	R0, R2, #0	;store it in buffer
		not	R0, R0		;subtract R4-R0
		ADD	R0, R0, #1	;to check for termination
		ADD	R0, R0, R4	;char stored in R4
		BRz	QUIT
		ADD	R2, R2, #1	;increment buffer pointer
		BR	START		;repeat
QUIT	HALT


TERM	.fill   x001A	;CTRL/Z
KBSRA	.fill	xfe00
KBDRA	.fill	xfe02
BUFFER	.blkw	x0100
		.end
```

### Monitor Output
![[../img/w8-ss5-dsr.png|300]]
- DSR (xFE04)
	- display status register
	- transferring a character to DDR clears DSR
	- when the monitor is finished processing a character it sets DSR bit-15 (aka "please sir, may I have another")

![[../img/w8-ss6-ddr.png|300]]
- DDR (XFE06)
	- display data register
	- transfer character to this address to print it on the monitor

### Example Code: Writing To The Display
```
; Write the contents of a string to the display
		.orig 	x3000
		LEA R2, BUFFER	;initialize buffer pointer
START	LDR	R0, R2, 0	;get char into R0
		BRz	QUIT		;terminate on null
WAIT	LDI	R3, DSRa	;are we ready?
		BRzp WAIT
		STI	R0, DDRa	;send R0 to monitor
		ADD	R2, R2, 1	;move buffer pointer over 1
		BR	START
QUIT	HALT

DSRa	.fill	xFE04
DDRa	.fill	xFE06
BUFFER	.stringz "Hello, World!"
		.end
```

### Full Implementation Of LC-3 Memory-Mapped I/O
![[../img/w8-ss7-full-implementation-memory-mapped-io.png|500]]
- because of interrupt enable bits, status registers (KBSR/DSR) must be written as well as read

