# **[CS 2110] - Week 11: Introduction To GBA & Introduction To DMA**
## Introduction To GBA
### Why GBA?
- programming on bare metal
- no operating system
- makes C seem more obvious
- relatively simple hardware
- slow...understand performance tradeoffs
- fun!

### Processor
- ARM-7-TDMI 3 stage pipelined RISC processor
- very popular embedded processor in 2000-2001
- 16.78 MHz clock speed
	- our laptop and computers are about 100 times faster than the GBA
- datatypes
	- 8 bit (char)
	- 16 bit (short)
	- 32 bit (int)
	- 32 bit address space

### Inputs
- 10 buttons
	- start
	- select
	- A
	- B
	- left
	- right
	- up
	- down
	- left shoulder
	- right shoulder
- the input is a 1 button register
	- 1 bit per button (0 -> pressed; 1 -> not pressed)

### Output
- 240 x 160 pixel color video display screen
	- 6 display modes
	- bit mapped
	- tiled
	- hardware support for sprites
- sound effect generators
- direct sound hardware (DAC)

### Programming On The GBA
- use the tutorial at http://www.coranac.com/tonc/text/

### Datatypes On The GBA
- integers
	- all can be signed, the default, or unsigned
	- char (1 byte)
	- short int OR short (2 bytes)
	- int (4 bytes)
	- long int / long (8 bytes)
- floating point
	- avoid because theyâ€™re software emulated
	- float
	- double

### Device Registers
- GBA contains a register that controls the many video modes on the GBA
	- `REG_DISPCTL` is at `0x0400 0000`
	- to access `REG_DISPCTL` we can write either:
		- `*(unsigned short *)0x04000000`
		- `#define REG_DISPCTL (*(unsigned short *)0x04000000)`
- Note: we will use Mode 3 and BG2
	- `REG_DISPCTL = 0x403`
		- `0x403` since we need to turn on the BG2 bit as well as bit 0 and 1 for Mode 3

![[../img/w11-ss1-reg-dispctl.png|500]]

### Video Memory (In Mode 3)
- we use a `videoBuffer` to tell the GBA hardware what values we want to display on the screen
	- `videoBuffer` is a 1D array of pixels (actually a 2D array laid out in 1D)
	- video memory begins at `0x06000000`
- consists of 160 x 240-bit unsigned shorts
	- the display has 160 rows and 240 columns
- rows are assigned contiguously
- **offset**: address relative to video memory
	- a pixel at row $n$, column $m$ would be:
		- `offset = n * (total number of columns) + m`
	- the address in the GBA would be:
		-  `0x06000000 + offset`

### Setting A Pixel To A Color
- colors are set using 16-bit binary numbers
	- bit 0-4 control red
	- bit 5-9 control green
	- bit 10-14 control blue
	- bit 15 is ignored
- ex. 0x0000 is black, 0x8000 is also black
- ex. 0x7C00 -> blue

![[../img/w11-ss2-binary-representation-of-a-color.png|500]]

- to set a pixel just do:
```
unsigned short *videoBuffer = (unsigned short *)0x0600000;
videoBuffer[offset] = 0x7fff; // or whatever color in hex
```

### Blanking
- GBA screen is refreshed at 60 Hz
- there are pauses in the drawing process
	- for each scanline (160 lines)
		- raw scanline (240 pixels)
		- Hblank (68 pixels)
	- Vblank (68 scanlines)
- **tearing**: the `videoBuffer` is updated during VDraw, causing the top half of the screen to show the old image and the bottom half to show the new image
- to avoid tearing, positional data is usually updated at the VBlank
	- this is why most games run at 60 or 30 fps

### HBlank And VBlank
- **VDraw**: GBA copies one row of pixels at a time from the `videoBuffer` to the screen
	- not instantaneous (aka halfway through VDraw, only half of the scanlines have been drawn)
- **VBlank**: nothing happens
	- you want to update `videoBuffer` during VBlank

![[../img/w11-ss3-vblank-and-hblank.png|400]]

- during `vdraw` perform other useful computations
- during `vblank` update `videoBuffer`

### Implementing `waitForVBlank`
- `SCANLINECOUNTER > 160` means GBA is in VBlank
	- issue 1: scanline is past 160, there is not enough time to update
	- issue 2: app logic runs too fast and we draw 2 frames during the same VBlank
- solution -> wait for `SCANLINECOUNTER == 160` and wait for `SCANLINECOUNTER` past VBlank to come back to VBlank

```
void waitForVBlank() {
	while (SCANLINECOUNTER > 160);
	while (SCANLINECOUNTER < 160);
	vBlankCounter++;
}

```

### Drawing Times
- a full screen refresh takes exactly 280896 cycles, divided by the clock speed which gives a frame rate of 59.73
- from the draw/blank periods, we can see that there are 4 cycles per pixel and 1232 cycles per scanline

![[../img/w11-ss4-drawing-times.png|250]]

---
## Introduction To DMA
### Direct Memory Access (DMA)
- hardware supported data copy
	- optimized large array copies (up to 10x as fast as array copies)
	- you set it up, the CPU is halted, data is transferred, and CPU gains back control
	- Note: reckless use of DMA can block interrupts
- DMA is fast but not instant
	- cannot draw a full-screen image in a single VBlank cycle, but it can draw without tearing (before VDraw catches up)

### The DMA Controller
- the DMA controller is not connected to the CPU, but the CPU can control it by writing to specific memory locations
- when DMA operates, it "steals" cycles from the CPU, and will return control to the CPU once it completes
- there are 12 DMA registers for 4 DMA channels (since each channel has a source, destination, and control register)

### DMA Channels
- channel 0
	- highest priority
	- time critical operations
- channel 1 and 2
	- transfer sound chunks to sound buffer
- channel 3
	- lowest priority
	- general purpose copies, like loading tiles or bitmaps into memory

### Using DMA
- source
	- `REG_DMAxSAD` (x = 0, 1, 2, 3)
	- the location of the data that will be copied (typically short pointers/addresses)
	- Note: takes an address not a value
- destination
	- `REG_DMAxDAD`
	- where to copy the data do (typically a pointer to `videoBuffer` with offset added)
- amount
	- `REG_DMAxCNT` (DMA control)
	- how much to copy

### DMA Control Register (REG_DMAxCNT)
- lower 16 bits contain amount to transfer
- upper 16 bits contain other options

|bits|name|define|description|
|-|-|-|-|
|0~15|N|-|number of transfers|
|21~22|DA|`DMA_DST_INC`|00: increment after each transfer (default)|
|||`DMA_DST_DEC`|01: decrement after each transfer|
|||`DMA_DST_FIXED`|10: none; address is fixed|
|||`DMA_DST_RESET`|11: increment the destination during the transfer and reset to the original value when done|
|23~24|SA|`DMA_SRC_INC`|00: increment after each transfer (default); aka memory copy|
|||`DMA_SRC_DEC`|01: decrement after each transfer|
|||`DMA_SRC_FIXED`|10: none; address is fixed; aka memory fill|
|25|R|`DMA_REPEAT`|repeats the copy at each VBlank or HBlank if the DMA timing has been set to those modes|
|26|CS|`DMA_16`|chunk size 16, sets DMA to copy by halfword (if 0)|
|||`DMA_32`|chunk size 32, sets DMA to copy by word (if 1)|
|28~29|TM|`DMA_NOW`|00: start immediately|
|||`DMA_AT_VBLANK`|01: start at VBlank|
|||`DMA_AT_HBLANK`|10: start at HBlank|
|||`DMA_AT_REFRESH`|11: ???|
|30|I|`DMA_IRQ`|interrupt request; raise an interrupt when finished|
|31|En|`DMA_ON`|enable the DMA transfer for this channel|
- Note: `DMA_SRC_RESET` doesn't exist for `DMA_SRC` as code $11_2$ is forbidden
- Note: make local variables `volatile` if using their address for a DMA fill

### DMA Example: Image On Screen
- when both source and destination are set to increase (`DMA_SRC_INC` and `DMA_DST_INC`) after each copy,an element-wise copy will occur
	-	useful for drawing images

### DMA Example: Color On Screen
- if the destination is set to increment (`DMA_DST_INC`) but source is fixed (`DMA_SRC_FIXED`), then a single value will be used to fill the entire buffer
	- useful for filling the screen with a single color

### Non-Full Screen Images
- to copy non-full screen images, copy line by line
	- this is because the next line of the source is not the next line of the destination (see below)

![[../img/w11-ss5-non-full-screen-images.png|300]]

### DMA Setup
- DMA_CONTROLLER struct with the 3 registers
```
typedef struct {
	const volatile void *src;	// 4 bytes
	const volatile void *dst;	// 4 bytes
	u32 cnt;					// 32 bits -> 4 bytes
}, DMA_CONTROLLER
	
#define DMA((volatile DMA_CONTROLLER *) 0x040000b0)
#define DMA_TRANSFER(_dst, _src, _count, _ch, _mode)

do {
	DMA[_ch].cnt = 0
	DMA[_ch].src = (const void*)(_src)
	DMA[_ch].dst = (void*)(_dst);
	DMA[_ch].cnt = (_count) | (_mode)
} while(0)

void dma_memcpy(void *dst, const void *src, u16 count) {
	DMA[3].cnt = 0
	DMA[3].src = src
	DMA[3].dst = dst
	DMA[3].cnt = count | DMA_32 | DMA_ON;
}
```
- we map a struct array (of 4 elements, 1 for each channel) over the DMA registers
	- ex. `DMA[3]` is used to access channel 3
	- Note: each channel occupies 12 bytes

### DMA Timing
- clearing a DMA register before its scheduled copy occurs will stop it from ever happening
	- careful when using delayed DMA
- even immediate DMA has a 2 cycle delay
	- DMA calls in immediate succession could cancel the earlier one
	- 2 cycles is short enough that returning from the DMA setup function allows the copy to begin before other code executes

### Loop Template
```
// initialize

while true {
	previousState = currentState
	
	// check buttons
	// calculate new values for currentState
	
	waitForVBlank();
	
	// undraw using previousState
	// draw using currentState
	
	// set gameState to INITPLAY
	
	while true {
		previousState = currentState
		
		if (gameState == PLAY) {
			// check buttons
			// calculate new values for currentState
		} else if (gameState == INITPLAY) {
			// initialize the currentState
		}
		
		waitForVBlank();
		
		if (gameState == PLAY) {
			// undraw using previousState
			// draw using currentState
		} else if (gameState == INITPLAY) {
			gameState = PLAY;
		}
	}
}
```